---
description: Apply these rules when making changes to the project
globs: 
alwaysApply: false
---

Update this rule if user requested changes to the project requirement, etc.
# Backend Structure Document

This document outlines the backend architecture for the RivalRecon application, which uses Next.js API Routes and Supabase as the primary backend technologies.

## Architecture Overview

The backend of RivalRecon is built using a combination of:

1. **Next.js API Routes** - For handling API requests and server-side logic
2. **Supabase** - For database storage, authentication, and real-time functionality
3. **Edge Functions** - For specialized serverless functions that require additional processing

This architecture provides a scalable, maintainable, and secure foundation for the application.

## Next.js API Routes Structure

API routes are organized in the `app/api` directory following the App Router pattern:

```
app/
├── api/
│   ├── auth/
│   │   └── [...supabase]/
│   │       └── route.ts       # Handles auth callbacks from Supabase
│   │   ├── competitors/
│   │   │   ├── route.ts           # GET, POST handlers for competitors collection
│   │   │   └── [id]/
│   │   │   │   └── route.ts       # GET, PUT, DELETE handlers for specific competitor
│   │   │   ├── reports/
│   │   │   │   ├── route.ts           # Handlers for reports collection
│   │   │   │   ├── [id]/
│   │   │   │   │   └── route.ts       # Handlers for specific report
│   │   │   │   └── generate/
│   │   │   │   │   └── route.ts       # Handler for report generation
│   │   │   └── webhooks/
│   │   │       └── route.ts          # Webhooks for external integrations
```

### API Route Implementation Pattern

Each API route follows a consistent pattern:

```typescript
// app/api/competitors/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { z } from 'zod';

// Define validation schema for request body
const competitorSchema = z.object({
  name: z.string().min(1),
  website: z.string().url().optional(),
  industry: z.string().optional(),
  notes: z.string().optional(),
});

export async function GET(request: NextRequest) {
  const supabase = createRouteHandlerClient({ cookies });
  
  // Check authentication
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  // Get query parameters
  const searchParams = request.nextUrl.searchParams;
  const query = searchParams.get('query') || '';
  
  // Fetch data from Supabase
  const { data, error } = await supabase
    .from('competitors')
    .select('*')
    .ilike('name', `%${query}%`)
    .order('name');
    
  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
  
  return NextResponse.json(data);
}

export async function POST(request: NextRequest) {
  const supabase = createRouteHandlerClient({ cookies });
  
  // Check authentication
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  // Parse and validate request body
  try {
    const body = await request.json();
    const validatedData = competitorSchema.parse(body);
    
    // Add user ID to the data
    const dataWithUser = {
      ...validatedData,
      user_id: session.user.id,
    };
    
    // Insert into Supabase
    const { data, error } = await supabase
      .from('competitors')
      .insert(dataWithUser)
      .select()
      .single();
      
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    
    return NextResponse.json(data, { status: 201 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors }, { status: 400 });
    }
    return NextResponse.json({ error: 'Invalid request' }, { status: 400 });
  }
}
```

## Supabase Database Schema

The Supabase database is structured with the following tables:

### Core Tables

1. **profiles**
   - Stores user profile information
   - Linked to Supabase Auth users
   - Fields: id (UUID), email, full_name, avatar_url, created_at, updated_at

2. **competitors**
   - Stores information about competitors being tracked
   - Fields: id (UUID), name, website, industry, notes, user_id (FK to profiles), created_at, updated_at

3. **products**
   - Stores product information for competitors
   - Fields: id (UUID), name, description, price, competitor_id (FK to competitors), created_at, updated_at

4. **reports**
   - Stores generated reports
   - Fields: id (UUID), title, description, date_range, user_id (FK to profiles), created_at, updated_at

5. **report_items**
   - Stores individual items within reports
   - Fields: id (UUID), report_id (FK to reports), item_type, content, order, created_at, updated_at

### Junction Tables

1. **competitor_tags**
   - Links competitors with tags
   - Fields: id (UUID), competitor_id (FK to competitors), tag_id (FK to tags)

2. **report_competitors**
   - Links reports with competitors
   - Fields: id (UUID), report_id (FK to reports), competitor_id (FK to competitors)

### Reference Tables

1. **tags**
   - Stores categorization tags
   - Fields: id (UUID), name, color, created_at, updated_at

### Row-Level Security (RLS) Policies

All tables implement RLS policies to ensure data security:

```sql
-- Example RLS policy for the competitors table
CREATE POLICY "Users can only see their own competitors"
ON competitors
FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own competitors"
ON competitors
FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own competitors"
ON competitors
FOR UPDATE
USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own competitors"
ON competitors
FOR DELETE
USING (auth.uid() = user_id);
```

## Authentication

Authentication is handled by Supabase Auth with Next.js integration:

1. **Server-Side Authentication**
   - Uses `createServerComponentClient` from `@supabase/auth-helpers-nextjs`
   - Implemented in Server Components for protected routes

2. **Client-Side Authentication**
   - Uses `createClientComponentClient` from `@supabase/auth-helpers-nextjs`
   - Implemented in Client Components for login/signup forms and user profile

3. **Middleware Authentication**
   - Uses `createMiddlewareClient` from `@supabase/auth-helpers-nextjs`
   - Implemented in `middleware.ts` to protect routes

### Authentication Flow

```typescript
// middleware.ts
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs';
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export async function middleware(req: NextRequest) {
  const res = NextResponse.next();
  const supabase = createMiddlewareClient({ req, res });
  
  const { data: { session } } = await supabase.auth.getSession();
  
  // Protect dashboard routes
  if (!session && req.nextUrl.pathname.startsWith('/dashboard')) {
    const redirectUrl = new URL('/login', req.url);
    redirectUrl.searchParams.set('redirectTo', req.nextUrl.pathname);
    return NextResponse.redirect(redirectUrl);
  }
  
  return res;
}

export const config = {
  matcher: ['/dashboard/:path*', '/api/:path*'],
};
```

## Edge Functions (Supabase)

For complex processing that doesn't fit into the Next.js API Routes, we use Supabase Edge Functions:

1. **Data Scraping Function**
   - Scrapes competitor websites for product information
   - Triggered by a scheduled cron job or manually through the UI

2. **Report Generation Function**
   - Generates PDF reports based on competitor data
   - Called when a user requests a new report

### Edge Function Implementation Pattern

```typescript
// Example Edge Function (supabase/functions/scrape-competitor/index.ts)
import { serve } from 'https://deno.land/std@0.131.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.7.1';
import * as cheerio from 'https://esm.sh/cheerio@1.0.0-rc.12';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const { competitorId } = await req.json();
    
    // Create Supabase client
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );
    
    // Get competitor info
    const { data: competitor, error: fetchError } = await supabaseClient
      .from('competitors')
      .select('*')
      .eq('id', competitorId)
      .single();
      
    if (fetchError) {
      throw fetchError;
    }
    
    // Scrape website
    const response = await fetch(competitor.website);
    const html = await response.text();
    const $ = cheerio.load(html);
    
    // Extract information (example)
    const products = [];
    $('.product').each((i, el) => {
      products.push({
        name: $(el).find('.product-name').text(),
        price: $(el).find('.product-price').text(),
        description: $(el).find('.product-description').text(),
      });
    });
    
    // Store scraped data
    const { error: insertError } = await supabaseClient
      .from('products')
      .upsert(
        products.map(product => ({
          competitor_id: competitorId,
          name: product.name,
          price: product.price,
          description: product.description,
        }))
      );
      
    if (insertError) {
      throw insertError;
    }
    
    return new Response(
      JSON.stringify({ success: true, products: products.length }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { 
        status: 400, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    );
  }
});
```

## Data Access Layer

To ensure consistent database access patterns, a data access layer is implemented:

### Server-Side Data Access

```typescript
// lib/server/db.ts
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { cache } from 'react';

// Create a cached Supabase client for server components
export const createServerClient = cache(() => {
  return createServerComponentClient({ cookies });
});

// Competitors data access
export async function getCompetitors(query = '') {
  const supabase = createServerClient();
  
  const { data, error } = await supabase
    .from('competitors')
    .select('*')
    .ilike('name', `%${query}%`)
    .order('name');
    
  if (error) throw error;
  return data;
}

export async function getCompetitorById(id: string) {
  const supabase = createServerClient();
  
  const { data, error } = await supabase
    .from('competitors')
    .select(`
      *,
      products (*)
    `)
    .eq('id', id)
    .single();
    
  if (error) throw error;
  return data;
}

// Other data access functions...
```

### Client-Side Data Access

```typescript
// lib/client/db.ts
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
import { Database } from '@/types/database.types';

// Create a Supabase client for client components
export const createClient = () => {
  return createClientComponentClient<Database>();
};

// Custom hooks for data access
export function useCompetitor(id: string) {
  const [competitor, setCompetitor] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    async function fetchCompetitor() {
      try {
        setLoading(true);
        const supabase = createClient();
        const { data, error } = await supabase
          .from('competitors')
          .select(`
            *,
            products (*)
          `)
          .eq('id', id)
          .single();
          
        if (error) throw error;
        setCompetitor(data);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    
    fetchCompetitor();
  }, [id]);
  
  return { competitor, loading, error };
}

// Other hooks and functions...
```

## Error Handling

A consistent approach to error handling is implemented across the backend:

1. **API Routes Error Handling**
   - Consistent error response format
   - HTTP status codes are used appropriately
   - Validation errors are returned with details

2. **Database Error Handling**
   - Supabase errors are properly captured and handled
   - Transactions are used where appropriate to ensure data integrity

3. **Logging**
   - Server-side errors are logged for monitoring
   - Critical errors trigger notifications via appropriate channels

## API Documentation

API routes are documented using JSDoc comments to provide clarity on usage:

```typescript
/**
 * @route GET /api/competitors
 * @description Get a list of competitors
 * @query {string} query - Filter competitors by name
 * @returns {Competitor[]} - Array of competitor objects
 * @throws {401} - If user is not authenticated
 * @throws {500} - If database query fails
 */
export async function GET(request: NextRequest) {
  // Implementation...
}
```

## Security Considerations

1. **Input Validation**
   - All user inputs are validated using Zod schemas
   - Sanitization is applied where necessary

2. **Authentication**
   - All protected routes check for valid session
   - JWT tokens are handled securely

3. **Database Security**
   - RLS policies ensure data isolation
   - Service role is only used where absolutely necessary

4. **CORS**
   - Proper CORS headers are implemented
   - Only necessary origins are allowed

5. **Rate Limiting**
   - API routes implement rate limiting where appropriate

## Deployment

The backend is deployed alongside the frontend through the Next.js application, with Supabase services managed separately:

1. **Next.js Application**
   - Deployed to Vercel
   - Environment variables configured for production

2. **Supabase Project**
   - Database migrations managed through SQL files
   - Edge Functions deployed via Supabase CLI

## Testing

Testing strategies for the backend include:

1. **Unit Tests**
   - Testing individual functions and utilities
   - Mock Supabase client for database operations

2. **Integration Tests**
   - Testing API routes with test database
   - End-to-end flow testing

3. **E2E Tests**
   - Cypress or Playwright for full application testing

## Performance Considerations

1. **Database Indexes**
   - Appropriate indexes on frequently queried columns

2. **Caching**
   - Response caching for appropriate endpoints
   - Leveraging Next.js caching mechanisms

3. **Query Optimization**
   - Efficient Supabase queries with proper selection
   - Pagination for large datasets

This document serves as a reference for understanding and maintaining the RivalRecon backend architecture. It outlines the structure, patterns, and best practices to ensure consistency and quality across the codebase.
